/*
 * Copyright (c) 2013 The Apache Software Foundation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 options
{
  STATIC=false;
  LOOKAHEAD=1;
  CACHE_TOKENS=true;
//  FORCE_LA_CHECK=true;
//  CHOICE_AMBIGUITY_CHECK=5;
  //LOOKAHEAD=2147483647;
  //DEBUG_PARSER=true;
  //DEBUG_TOKEN_MANAGER=true;
  //DEBUG_LOOKAHEAD=true;
}

PARSER_BEGIN(RdfPatchParserImpl)
package org.apache.marmotta.platform.ldp.patch.parser;

import org.openrdf.model.*;
import org.openrdf.model.impl.*;

import org.apache.marmotta.platform.ldp.patch.model.*;
import org.openrdf.rio.turtle.TurtleUtil;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

public class RdfPatchParserImpl implements RdfPatchParser {

    private HashMap<String, String> namespaces = new HashMap<String, String>();

    private URI createURI(String uri) {
        return new URIImpl(unwrapUri(uri));
    }

    private URI createURI(String prefix, String local) {
        return new URIImpl(namespaces.get(prefix)+local);
    }

    private BNode createBNode(String id) {
        return new BNodeImpl(id);
    }

    private Literal createLiteral(String value, String lang, String type) {
        value = TurtleUtil.decodeString(value.substring(1, value.length() - 1));
        if (lang != null) {
            return new LiteralImpl(value, lang);
        } else if (type != null) {
            return new LiteralImpl(value, createURI(type));
        } else {
            return new LiteralImpl(value);
        }
    }

    private Literal createLongLiteral(String value, String lang, String type) {
        value = value.substring(2, value.length() - 2);
        return createLiteral(value, lang, type);
    }

    private String unwrapUri(String uri) {
        if (uri.startsWith("<")) {
            uri = uri.substring(1);
        }
        if (uri.endsWith(">")) {
            uri = uri.substring(0, uri.length()-1);
        }
        return uri;
    }

}
PARSER_END(RdfPatchParserImpl)

SKIP : {
 	" "
|	"\r"
|	"\t"
|	"\n"
}

MORE: {
 "\"\"\"" : WithinLongString |
 "\"" : WithinString
}

<WithinString> TOKEN: {
  <STRLIT: "\""> : DEFAULT
}

<WithinLongString> TOKEN: {
  <STRLONGLIT: "\"\"\""> : DEFAULT
}


<WithinString> MORE: {
  <~["\n","\r"]>
}

<WithinLongString> MORE: {
  <~[]>
}

TOKEN : {
  < OP:        ["A","D"] > |
  < REPEAT:    "R" >  |
  < UNDEFINED: "U" >  |
  < PREFIX:    "@prefix" > |
  < DOT:       "." >  |
  < COLON:     ":" >  |
  < BNODE:     "_:" > |
  < URI:       "<" (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`", "\u0000"-"\u0020"])+ ">" > |
  < IDENT:     ["a"-"z","A"-"Z","0"-"9","_"](["a"-"z","A"-"Z","0"-"9","_","'","-", "."])* > |
  < LANG:      "@" >  |
  < TYPE:      "^^" >
}

SPECIAL_TOKEN : {
  <COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}



public List<PatchLine> parsePatch() : {
    Token id, prefix, op;
    Statement statement;
    LinkedList<PatchLine> diff = new LinkedList<PatchLine>();
    namespaces.clear();
}
{
    ( <PREFIX> id = <IDENT> <COLON> prefix = <URI> <DOT> { namespaces.put(id.image, unwrapUri(prefix.image));} )*
    (
      op = <OP> statement = parseStatement() <DOT> { diff.add(new PatchLine(PatchLine.Operator.fromCommand(op.image), statement)); }
    )*
    <EOF>
    {
        return diff;
    }
}

private Statement parseStatement() : {
    Token t1 = null, t2 = null, t3 = null;
    Token lVal = null, lLang = null, lType = null;
    Resource subject;
    URI predicate;
    Value object;
}
{
    ( t1 = <URI> { subject = createURI(t1.image); } |
        t1 = <IDENT> <COLON> t2 = <IDENT> { subject = createURI(t1.image, t2.image); } |
        <BNODE> t1 = <IDENT> { subject = createBNode(t1.image); } |
        <REPEAT> { subject = null; }
    )
    ( t1 = <URI> { predicate = createURI(t1.image); } |
        t1 = <IDENT> <COLON> t2 = <IDENT> { predicate = createURI(t1.image, t2.image); } |
        <REPEAT> { predicate = null; }
    )
    ( t1 = <URI> { object = createURI(t1.image); } |
        t1 = <IDENT> <COLON> t2 = <IDENT> { object = createURI(t1.image, t2.image); } |
        <BNODE> t1 = <IDENT> { object = createBNode(t1.image); } |
        lVal = <STRLIT> (<LANG> lLang = <IDENT>)? (<TYPE> lType = <URI>)? {
            object = createLiteral(lVal.image, lLang!=null?lLang.image:null, lType!=null?lType.image:null);
        } |
        lVal = <STRLONGLIT> (<LANG> lLang = <IDENT>)? (<TYPE> lType = <URI>)? {
            object = createLongLiteral(lVal.image, lLang!=null?lLang.image:null, lType!=null?lType.image:null);
        } |
        <REPEAT> { object = null; }
    )
    { return new WildcardStatement(subject, predicate, object); }
}